# cpp_Checker-Challenge
C++练习 皇后问题

# P1219 [USACO1.5] 八皇后 Checker Challenge

题目描述：
一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。
![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)
上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：
行号 $1\ 2\ 3\ 4\ 5\ 6$
列号 $2\ 4\ 6\ 1\ 3\ 5$
这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  
并把它们以上面的序列方法输出，解按字典顺序排列。  
请输出前 $3$ 个解。最后一行是解的总个数。

输入格式：
一行一个正整数 $n$，表示棋盘是 $n \times n$ 大小的。

输出格式：
前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

思路：说难也难说简单也简单，最难的更多是代码实现。
递归，回溯，深搜，都在本题有所运用。简单讲就是遍历每一行的每一列，判断是否能放皇后，判定条件非常巧妙，用三个数组分别代表该格子所在的列，顺斜线，逆斜线。
所在列很容易实现，因为一列只能存在一个皇后，所以再放置皇后之后将该列标记为不可放置，斜线的话找规律，可得列数和行数相加减都是同一个数，即，只要是同一斜线，
列号与行号的加减都一样，所以用这个特性来标记一条斜线上的所有各自，之后判断时，将该格子的列号和行号计算就能得知是否可以放置。
至于遍历，第一行选择好后，标记，递进去，在第二行开始选择，如果该行没有合适的位置（所有列遍历完毕），归，说明第一行的这一个格子没有解答，将这个格子的状态清楚，
去下一个格子，再进入第二行，如此反复，知道step也就是皇后的数量已经超过了行数（所有行都已经放置了皇后，代表得到了一种解答），按要求输出。
